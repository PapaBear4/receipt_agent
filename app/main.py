from pathlib import Path
from datetime import datetime
from typing import Dict, Optional, Tuple, cast
from fastapi import FastAPI, UploadFile, File, Form, Request
from fastapi.responses import HTMLResponse, RedirectResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

from app.config import settings
import logging
import json
from app.services.ocr import ocr_image, ocr_image_detailed, draw_annotated_overlay
from app.services.ocr import ocr_on_cropped_image, draw_overlay_on_image
from app.services.image_preproc import crop_receipt, make_receipt_preview
from app.services.llm import extract_fields_from_text, ollama_health, select_model
from app.utils.csv_writer import CSVWriter
from app.utils.date_utils import normalize_date_to_mmddyyyy

app = FastAPI(title="Receipt Agent MVP")

# Module logger
logger = logging.getLogger(__name__)
if settings.DEBUG:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

# Static mount for uploaded/processed images for preview
app.mount("/data", StaticFiles(directory=str(settings.DATA_DIR)), name="data")

templates = Jinja2Templates(directory=str(Path(__file__).parent / "templates"))

csv_writer = CSVWriter(settings.CSV_PATH)


@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    logger.debug("Render upload page")
    return templates.TemplateResponse("upload.html", {"request": request})


@app.get("/health")
async def health():
    # Basic liveness; optionally could check Ollama port reachability
    logger.debug("Health check OK")
    return {"status": "ok"}


@app.get("/health/llm")
async def health_llm():
    info = ollama_health()
    # Also report the model that would actually be used (with fallback selection)
    model_value = str(info.get("model", ""))
    info["used_model"] = select_model(model_value)
    # Log concise summary
    logger.info(
        "LLM health: endpoint_ok=%s model_ok=%s model=%s",
        info.get("endpoint_ok"),
        info.get("model_ok"),
        info.get("model"),
    )
    return info


@app.get("/health/llm/test")
async def health_llm_test(q: str = "Walmart 06/09/2025 Total $14.23"):
    used_model = select_model()
    fields = extract_fields_from_text(q)
    return {"model": used_model, "fields": fields}


@app.post("/upload")
async def upload_receipt(request: Request, file: UploadFile = File(...)):
    # Save original upload
    filename = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{file.filename}"
    dest_path = settings.UPLOADS_DIR / filename
    logger.info("Upload received: %s -> %s", file.filename, dest_path)
    with dest_path.open("wb") as f:
        f.write(await file.read())

    # Two-step: crop/warp first, then OCR on cropped image
    preview_url = None  # MVP: not shown in UI; kept for future wiring
    cropped_for_ocr = None
    try:
        import importlib
        cv2 = importlib.import_module("cv2")
        logger.info("Cropping/warping receipt: %s", dest_path)
        cropped = crop_receipt(str(dest_path))
        # MVP: we won't show preview yet, but keep the cropped image in memory for OCR
        cropped_for_ocr = cropped
    except Exception as e:
        if settings.DEBUG:
            logger.exception("Failed to crop/preview: %s", e)
        cropped_for_ocr = None

    # OCR on cropped (or original if crop failed)
    annotated_url = None
    ocr_json_url = None
    detailed = None
    raw_text = ""
    try:
        import importlib
        cv2 = importlib.import_module("cv2")
        if cropped_for_ocr is None:
            logger.info("Crop failed; using original image for OCR")
            cropped_for_ocr = cv2.imread(str(dest_path))
        logger.info("Starting OCR on cropped image")
        debug_base = Path(filename).stem
        detailed = ocr_on_cropped_image(cropped_for_ocr, debug_basename=debug_base)
        raw_text = detailed.get("text", "")
        logger.info("OCR complete: %d chars, %d lines", len(raw_text or ""), len(detailed.get("lines", [])))
    except Exception:
        logger.exception("OCR failed for %s", dest_path)
        raw_text = ""
        detailed = None

    # LLM extraction (resilient)
    logger.info("Starting LLM field extraction")
    fields = extract_fields_from_text(raw_text)
    if settings.DEBUG:
        logger.debug("LLM fields: keys=%s", list(fields.keys()))

    # Defaults for review form
    date_val = normalize_date_to_mmddyyyy(fields.get("date", ""))
    payee_val = fields.get("payee", "")
    outflow_val = "" if not fields.get("total") else f"{float(fields['total']):.2f}"
    memo_val = f"Generated by Agent Fineas from {file.filename}"

    # Try to associate extracted fields to OCR lines (simple contains match)
    associated_lines: Dict[str, Optional[tuple]] = {"date": None, "payee": None, "total": None}
    lines = []
    if detailed:
        lines = detailed.get("lines", [])
        lids = detailed.get("line_ids", [])
        def find_lid(value: str):
            if not value:
                return None
            v = value.strip().lower()
            best = None
            for lid, line in zip(lids, lines):
                if v and v in line.lower():
                    best = lid
                    break
            return best
        associated_lines["payee"] = find_lid(payee_val)
        # for date and total, try relaxed patterns
        associated_lines["date"] = find_lid(date_val)
        associated_lines["total"] = find_lid(outflow_val)

        try:
            logger.info("Creating overlay for %s", dest_path)
            highlight_map = {k: v for k, v in associated_lines.items() if v is not None}
            highlight_map = cast(Dict[str, tuple], highlight_map)
            # Draw overlay directly on the cropped image used for OCR to keep coordinates aligned
            # Use the exact processed image used by OCR for coordinate alignment
            proc_image = detailed.get("proc_image")
            if proc_image is None:
                import importlib
                cv2 = importlib.import_module("cv2")
                proc_image = cropped_for_ocr if cropped_for_ocr is not None else cv2.imread(str(dest_path))
            overlay = draw_overlay_on_image(proc_image, detailed["words"], detailed["line_ids"], highlight_map)
            overlay_name = f"overlay_{filename}.jpg"
            overlay_path = settings.PROCESSED_DIR / overlay_name
            import importlib
            cv2 = importlib.import_module("cv2")
            cv2.imwrite(str(overlay_path), overlay)
            annotated_url = f"/data/processed/{overlay_name}"
            # Also dump a JSON file with OCR words/lines/boxes for download
            try:
                serial = {
                    "text": detailed.get("text", ""),
                    "lines": detailed.get("lines", []),
                    "words": detailed.get("words", []),
                    "line_ids": detailed.get("line_ids", []),
                    "size": list(detailed.get("size", [])) if isinstance(detailed.get("size"), (list, tuple)) else detailed.get("size"),
                }
                ocr_json_name = f"ocr_{Path(filename).stem}.json"
                ocr_json_path = settings.PROCESSED_DIR / ocr_json_name
                ocr_json_path.write_text(json.dumps(serial, indent=2))
                ocr_json_url = f"/data/processed/{ocr_json_name}"
            except Exception as e:
                if settings.DEBUG:
                    logger.exception("Failed to write OCR JSON: %s", e)
        except Exception as e:
            if settings.DEBUG:
                logger.exception("Failed to create overlay: %s", e)
            annotated_url = None

        if settings.DEBUG:
            try:
                debug_dump = {
                    "assoc": associated_lines,
                    "lines": lines,
                    "lids": [list(l) for l in lids],
                }
                dbg_path = settings.PROCESSED_DIR / f"debug_{filename}.json"
                dbg_path.write_text(json.dumps(debug_dump, indent=2))
                logger.debug("Wrote debug dump: %s", dbg_path)
            except Exception:
                logger.exception("Failed to write debug dump for %s", dest_path)

    logger.info("Rendering review page: image_url=/data/uploads/%s, annotated=%s", filename, bool(annotated_url))
    return templates.TemplateResponse(
        "review.html",
        {
            "request": request,
            "image_url": f"/data/uploads/{filename}",
            "annotated_url": annotated_url,
            "ocr_json_url": ocr_json_url,
            # "preview_url": preview_url,  # hidden in MVP
            "raw_text": raw_text,
            "date": date_val,
            "payee": payee_val,
            "outflow": outflow_val,
            "memo": memo_val,
            "stored_filename": filename,
            "original_filename": file.filename,
            "assoc": associated_lines,
            "ocr_lines": lines,
            "debug": settings.DEBUG,
        },
    )


@app.post("/save")
async def save_receipt(
    request: Request,
    stored_filename: str = Form(...),
    original_filename: str = Form(...),
    date: str = Form(...),
    payee: str = Form(...),
    outflow: str = Form(...),
    memo: str = Form(...),
):
    # Validate
    logger.info("Saving receipt: stored=%s original=%s", stored_filename, original_filename)
    norm_date = normalize_date_to_mmddyyyy(date)
    errors = []
    if not norm_date:
        errors.append("Invalid or missing date")
    payee = (payee or "").strip()
    if not payee:
        errors.append("Payee is required")
    amount: float = 0.0
    try:
        amount = float(outflow)
        if amount <= 0:
            errors.append("Outflow must be > 0")
    except Exception:
        errors.append("Outflow must be a number")

    if errors:
        logger.warning("Validation errors: %s", errors)
        # Re-render review with errors
        image_url = f"/data/uploads/{stored_filename}"
        raw_text, _ = ocr_image(str(settings.UPLOADS_DIR / stored_filename))
        return templates.TemplateResponse(
            "review.html",
            {
                "request": request,
                "errors": errors,
                "image_url": image_url,
                "raw_text": raw_text,
                "date": date,
                "payee": payee,
                "outflow": outflow,
                "memo": memo,
                "stored_filename": stored_filename,
                "original_filename": original_filename,
            },
        )

    # Append to CSV
    csv_writer.append_row([norm_date, payee, "", memo, f"{amount:.2f}", ""])
    logger.info("Appended to CSV: %s", settings.CSV_PATH)

    # Copy to processed
    src = settings.UPLOADS_DIR / stored_filename
    timestamped = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{stored_filename}"
    dst = settings.PROCESSED_DIR / timestamped
    try:
        dst.write_bytes(src.read_bytes())
        logger.info("Copied to processed: %s", dst)
    except Exception:
        logger.exception("Failed to copy to processed: %s -> %s", src, dst)

    # Redirect to upload page (flash messages could be added later)
    logger.info("Redirecting to upload page")
    return RedirectResponse(url="/", status_code=303)


@app.get("/download/csv")
async def download_csv():
    logger.info("CSV download requested: %s", settings.CSV_PATH)
    return FileResponse(str(settings.CSV_PATH), media_type="text/csv", filename="ynab_receipts.csv")

