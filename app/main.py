from pathlib import Path
from datetime import datetime
from fastapi import FastAPI, UploadFile, File, Form, Request
from fastapi.responses import HTMLResponse, RedirectResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

from app.config import settings
import logging
import json
from app.services.ocr import ocr_image, ocr_image_detailed, draw_annotated_overlay
from app.services.llm import extract_fields_from_text
from app.utils.csv_writer import CSVWriter
from app.utils.date_utils import normalize_date_to_mmddyyyy

app = FastAPI(title="Receipt Agent MVP")

# Module logger
logger = logging.getLogger(__name__)
if settings.DEBUG:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

# Static mount for uploaded/processed images for preview
app.mount("/data", StaticFiles(directory=str(settings.DATA_DIR)), name="data")

templates = Jinja2Templates(directory=str(Path(__file__).parent / "templates"))

csv_writer = CSVWriter(settings.CSV_PATH)


@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    logger.debug("Render upload page")
    return templates.TemplateResponse("upload.html", {"request": request})


@app.get("/health")
async def health():
    # Basic liveness; optionally could check Ollama port reachability
    logger.debug("Health check OK")
    return {"status": "ok"}


@app.post("/upload")
async def upload_receipt(request: Request, file: UploadFile = File(...)):
    # Save original upload
    filename = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{file.filename}"
    dest_path = settings.UPLOADS_DIR / filename
    logger.info("Upload received: %s -> %s", file.filename, dest_path)
    with dest_path.open("wb") as f:
        f.write(await file.read())

    # OCR (resilient)
    annotated_url = None
    try:
        logger.info("Starting OCR: %s", dest_path)
        detailed = ocr_image_detailed(str(dest_path))
        raw_text = detailed.get("text", "")
        logger.info("OCR complete: %d chars, %d lines", len(raw_text or ""), len(detailed.get("lines", [])))
    except Exception:
        logger.exception("OCR failed for %s", dest_path)
        raw_text = ""
        detailed = None

    # LLM extraction (resilient)
    logger.info("Starting LLM field extraction")
    fields = extract_fields_from_text(raw_text)
    if settings.DEBUG:
        logger.debug("LLM fields: keys=%s", list(fields.keys()))

    # Defaults for review form
    date_val = normalize_date_to_mmddyyyy(fields.get("date", ""))
    payee_val = fields.get("payee", "")
    outflow_val = "" if not fields.get("total") else f"{float(fields['total']):.2f}"
    memo_val = f"Generated by Agent Fineas from {file.filename}"

    # Try to associate extracted fields to OCR lines (simple contains match)
    associated_lines = {"date": None, "payee": None, "total": None}
    lines = []
    if detailed:
        lines = detailed.get("lines", [])
        lids = detailed.get("line_ids", [])
        def find_lid(value: str):
            if not value:
                return None
            v = value.strip().lower()
            best = None
            for lid, line in zip(lids, lines):
                if v and v in line.lower():
                    best = lid
                    break
            return best
        associated_lines["payee"] = find_lid(payee_val)
        # for date and total, try relaxed patterns
        associated_lines["date"] = find_lid(date_val)
        associated_lines["total"] = find_lid(outflow_val)

        try:
            logger.info("Creating overlay for %s", dest_path)
            overlay = draw_annotated_overlay(str(dest_path), detailed["words"], detailed["line_ids"], associated_lines)
            overlay_name = f"overlay_{filename}.jpg"
            overlay_path = settings.PROCESSED_DIR / overlay_name
            import importlib
            cv2 = importlib.import_module("cv2")
            cv2.imwrite(str(overlay_path), overlay)
            annotated_url = f"/data/processed/{overlay_name}"
        except Exception as e:
            if settings.DEBUG:
                logger.exception("Failed to create overlay: %s", e)
            annotated_url = None

        if settings.DEBUG:
            try:
                debug_dump = {
                    "assoc": associated_lines,
                    "lines": lines,
                    "lids": [list(l) for l in lids],
                }
                dbg_path = settings.PROCESSED_DIR / f"debug_{filename}.json"
                dbg_path.write_text(json.dumps(debug_dump, indent=2))
                logger.debug("Wrote debug dump: %s", dbg_path)
            except Exception:
                logger.exception("Failed to write debug dump for %s", dest_path)

    logger.info("Rendering review page: image_url=/data/uploads/%s, annotated=%s", filename, bool(annotated_url))
    return templates.TemplateResponse(
        "review.html",
        {
            "request": request,
            "image_url": f"/data/uploads/{filename}",
            "annotated_url": annotated_url,
            "raw_text": raw_text,
            "date": date_val,
            "payee": payee_val,
            "outflow": outflow_val,
            "memo": memo_val,
            "stored_filename": filename,
            "original_filename": file.filename,
            "assoc": associated_lines,
            "ocr_lines": lines,
            "debug": settings.DEBUG,
        },
    )


@app.post("/save")
async def save_receipt(
    request: Request,
    stored_filename: str = Form(...),
    original_filename: str = Form(...),
    date: str = Form(...),
    payee: str = Form(...),
    outflow: str = Form(...),
    memo: str = Form(...),
):
    # Validate
    logger.info("Saving receipt: stored=%s original=%s", stored_filename, original_filename)
    norm_date = normalize_date_to_mmddyyyy(date)
    errors = []
    if not norm_date:
        errors.append("Invalid or missing date")
    payee = (payee or "").strip()
    if not payee:
        errors.append("Payee is required")
    try:
        amount = float(outflow)
        if amount <= 0:
            errors.append("Outflow must be > 0")
    except Exception:
        errors.append("Outflow must be a number")

    if errors:
        logger.warning("Validation errors: %s", errors)
        # Re-render review with errors
        image_url = f"/data/uploads/{stored_filename}"
        raw_text, _ = ocr_image(str(settings.UPLOADS_DIR / stored_filename))
        return templates.TemplateResponse(
            "review.html",
            {
                "request": request,
                "errors": errors,
                "image_url": image_url,
                "raw_text": raw_text,
                "date": date,
                "payee": payee,
                "outflow": outflow,
                "memo": memo,
                "stored_filename": stored_filename,
                "original_filename": original_filename,
            },
        )

    # Append to CSV
    csv_writer.append_row([norm_date, payee, "", memo, f"{amount:.2f}", ""])
    logger.info("Appended to CSV: %s", settings.CSV_PATH)

    # Copy to processed
    src = settings.UPLOADS_DIR / stored_filename
    timestamped = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{stored_filename}"
    dst = settings.PROCESSED_DIR / timestamped
    try:
        dst.write_bytes(src.read_bytes())
        logger.info("Copied to processed: %s", dst)
    except Exception:
        logger.exception("Failed to copy to processed: %s -> %s", src, dst)

    # Redirect to upload page (flash messages could be added later)
    logger.info("Redirecting to upload page")
    return RedirectResponse(url="/", status_code=303)


@app.get("/download/csv")
async def download_csv():
    logger.info("CSV download requested: %s", settings.CSV_PATH)
    return FileResponse(str(settings.CSV_PATH), media_type="text/csv", filename="ynab_receipts.csv")

